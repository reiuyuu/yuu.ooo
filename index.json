[{"categories":null,"contents":" Introduction Project 2: CS61BYoG is the third project (there is Project 0) in CS 61B Data Structures, Spring 2018. Its specific theme is Large Scale Design and Testing.1 As described in the material, the task is to create an engine for generating explorable worlds — that is, to design and implement a 2D tile-based game.\nBy \u0026ldquo;tile-based\u0026rdquo;, we mean the world for your game will consist of a 2D grid of tiles. By \u0026ldquo;game\u0026rdquo; we mean that the player will be able to walk around and interact with the world.2\nLet\u0026rsquo;s say, a minimal roguelike game would meet the requirement, so I add an \u0026lsquo;R\u0026rsquo; to BYoG; that is, Build Your Own Roguelike Game. Here I would like to talk about my solution briefly.\nWorld Generation The first goal of the project will be to write a world generator. The world will be pseudorandomly generated, including rooms and hallways, drawn using the tile engine provided. My final version will be as the image shown below. Not much surprise, but that\u0026rsquo;s what will cost 80% of the time in this project. You may say project 2 is about World Generation Algorithm.\nrandom map example\nOverview So I started googling for cool world generation algorithms and found Rooms and Mazes: A Procedural Dungeon Generator, an article about generating dungeons in roguelike games, by Bob Nystrom. In summary:\nPlace a bunch of random non-overlapping rooms. Fill in the remaining solid regions with mazes. Connect each of the mazes and rooms to their neighbors, with a chance to add some extra connections. Remove all of the dead ends.3 I have to say it quite matches the requirements, and its implementation is pretty fancy and neat. So I rewrote it in Java with minor modifications. My contribution seems minimal, but I thought it would be worth writing down and going into a few details, including three critical steps: addRooms, growMaze, then connectRegions.\naddRooms Starting with a 2D grid of WALL tile filled map, it first calls addRooms: Do a numRoomTries of attempts to place rooms. In each loop, it first creates a room with random width, height and position. Then checks if this room overlaps an existing one. If so, skip it; otherwise, dig it out, i.e. fill in the FLOOR tile.\ngrowMaze It then iterates every tile in the map and performs growMaze — a flood fill algorithm, where it could be. This resulted in the rest of the map being filled with mazes. Here, it is worth mentioning that as the maze incrementally grows from one tile to the next, it requires polling the current tile\u0026rsquo;s four directions, up, right, down, and left, every time. The trick to this is the preset CARDINALS:\n1 2 3 4 5 6 7 8 9 10 public static final Position[] CARDINALS = new Position[] { new Position(1, 0), new Position(0, 1), new Position(-1, 0), new Position(0, -1) } public Position turn(Position dir) { return new Position(this.x + dir.x, this.y + dir.y); } 1 2 3 4 for (Position dir : Position.CARDINALS) { newPos = oldPos.turn(dir); ... } connectRegions After filling in the rooms and mazes, find connections between them. We treat each region of tiles as a single vertex and each connector as an edge between them,3 and then it is all about finding a spanning tree:\nconnectRegions first creates a list of tiles (connectors) that can connect two or more regions and a map (merged) that keeps track of all merged regions, as well as a set of unconnected regions (openRegions). Then, it keeps connecting regions and updating the openRegions until it is down to one.\nThe process is pretty straightforward:\nPick a random room to be the main region. Pick a random connector that touches the main region and open it up. The connected region is now part of the main one. Unify it. Remove any extraneous connectors. If there are still connectors left, go to #2.3 All that remains is to make a few more tweaks. Remove all of the dead ends and inner walls, place an exit and one player, then we\u0026rsquo;re good to go. And I think I will stop here.\nInteractivity In the second phase of the game, you\u0026rsquo;ll add the ability for the user to actually play the game, and will also add user interface (UI) elements to your game to make it feel more immersive and informative.2\nGame UI Appearance The game uses the provided TileEngine, which makes heavy use of StdDraw, for displaying graphics. When the game runs with Core.Game.playWithKeyboard() method, it displays the menu with three options as shown below.\ngame menu\nWe may press N for \u0026ldquo;New Game\u0026rdquo; or L for \u0026ldquo;Load Game\u0026rdquo;, and the game start. The user interface consists of a 2D grid of tiles showing the current state of the world and a HUD that displays the description of the tile under the mouse pointer. And that\u0026rsquo;s it, without any unnecessary clutter or confusion.\ngame UI\nGame UI Behavior The game begins, and we can be in control of the \u0026lsquo;@\u0026rsquo; character to move up, left, down and right using the W, A, S, and D keys, respectively. That\u0026rsquo;s how we interact with the world. Here we use StdDraw to handle user input:\n1 2 3 4 5 6 7 private char solicitInput() { while (true) { if (StdDraw.hasNextKeyTyped()) { return Character.toUpperCase(StdDraw.nextKeyTyped()); } } } The game mechanics is that users win by moving the \u0026lsquo;@\u0026rsquo; character to a golden colored WALL tile representing the exit, without touching the wall along the way. There are no additional bells or whistles; I believe that\u0026rsquo;s all it needs to function correctly.\nSaving and Loading Your game must have the ability to save the game while playing and load the game in the exact state of the most recent save after quitting and opening the game back up.2\nThe technique to accomplish this is the Java interface Serializable. What it does is basically translate a data structure or object state into a format that can be stored or transmitted. Implementing the interface marks the class as \u0026ldquo;okay to serialize\u0026rdquo;, and Java then handles serialization internally.4\n1 2 3 4 public class MapGenerator extends StageBuilder { ... } public class Position extends StageBuilder { ... } public class Room extends StageBuilder { ... } public class Player extends StageBuilder { ... } 1 2 3 4 abstract class StageBuilder implements Serializable { private static final long serialVersionUID = 1234567890L; ... } Pseudorandom Another critical topic of this project is pseudorandom. By pseudorandom, it means that the world generated, given a different seed, did vary greatly; but for a certain seed, it is deterministic.\nThe Random object would work; it is guaranteed to output the same sequence of numbers, which is completely determined by an initial seed. And the same sequence of numbers determines the width, height and location of the rooms, how twists and turns the maze is, and every single connector. Thus, the world should yield exactly the same.\nEnd That\u0026rsquo;s my naive solution; you may grab the code here. I am pretty aware that the game I built doesn\u0026rsquo;t look nice or fun. Nonetheless, project 2 is not about games; what really matters is, as mentioned in the material:\nThe goal of this project is to teach you how to handle a larger piece of code with little starter code in the hopes of emulating something like a product development cycle.2\nAbout | CS 61B Spring 2018\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nProject 2: CS61BYoG | CS 61B Spring 2018\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nRooms and Mazes: A Procedural Dungeon Generator - journal.stuffwithstuff.com\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSerialization - Wikipedia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"Oct 30","permalink":"https://yuu.ooo/posts/byog/","tags":null,"title":"CS 61B Project 2: BYoG — Build Your Own Roguelike Game"},{"categories":null,"contents":" Ⅰ 我可以斷言\n我從未度過任何有意義的夏天\n如果沒有遇到他\n我的靈魂會潔淨許多吧\n這不是挺好的嘛\n先說結論\n我沒有向她搭話\n男女關係應配合彼此的步調謹慎經營\n而非莽撞地跟隨一年的觀光節日或活動時程來推進\nⅡ 我們去看看未來怎麼樣？\n這可是時光機的精髓呢！\n我也提個意見可以嗎？\n回到兩年前的春天如何？\n我已經看透你的想法了\n你一定是打算忠告一年級的自己\n好讓自己能有\n玫瑰色的大學生活對吧？\n聽好了，時光機是製造得出來的\n這可是世上的真理！\n是啊，這就是所謂時代的洪流\nⅢ 這樣沒關係嗎？\n這個遙控器要放回昨天\n我追著小津，他追著昨天的我\n而昨天的我追著昨天的明石\n你總是這樣，錯失眼前的好機會\n現在還來得及重來\n不然要時光機幹嘛？\nⅣ 在迎新會的時候去鐘樓下看看吧\n各社團都在等著新生\n那是通往無限光明未來的大門喔\n想度過充實的學生時代\n就應該加入社團 不然啊\n你會落得虛度四年的下場喔\n比如天天關在這種公寓的一間房裡\n到底有什麼可能性可言？\n學長，請邀我去看五山送火\n請你一定要做到\nⅤ 大家在 209 號房為冷氣舉行守靈夜\n盛夏的炒飯正是青春的晚膳！\n這種事怎麼可能當面說\n我還是有時空旅行者的自覺的\n所以說這一切都是早就註定好的嗎？\n我們的夏天就這樣邁向結束\nⅥ 我還是閃耀著光芒的大一新生時\n在我眼前有無數扇通往薔薇色大學生活的大門\n和黑髮少女們一起搭乘戀愛慢速列車\n這麼想的自己實在是無藥可救的笨蛋\n不論選擇了什麼道路\n最終都會走到現在這樣的結局\n這究竟是怎麼一回事？\n進入大學後約兩年\n徘徊在荒野般的四疊半\n看著有幹勁的人\n逐漸墮落實在是大快人心呢\n「四疊半時光機藍調」 E06, 9min, 37s\n","date":"Oct 17","permalink":"https://yuu.ooo/posts/tatami-time-machine-blues/","tags":null,"title":"四疊半時光機藍調"}]